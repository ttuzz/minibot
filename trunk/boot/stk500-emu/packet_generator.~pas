unit packet_generator;

interface
  uses Classes, SysUtils;

  type TData = array of byte;
  type TPacket = class(TObject)
    constructor create(source: string);
    destructor free;
  private
    firmware: TMemoryStream;
    _is_end: boolean;
    number: byte;
    
    function convert_one_string(s: string): TData;
    function convert_hex(source: string; var dest: TMemoryStream): boolean;
  public
    function next: string;
    function cancel: string;
    function is_end: boolean;
    function amount: word;              // не использовать для циклов! только в качестве информации!
    function firmware_overload: boolean;
  end;
implementation

function TPacket.convert_one_string(s: string): TData;
// парсит строку intel hex файла
// ЗАТОЧЕНА ПОД БАСКОМ, ПОЛНОЦЕННЫЙ ПАРСИНГ НЕ ПРОИЗВОДИТСЯ
var
  len: array of byte;
  s_len: string;
  i: byte;
begin
  delete(s, 1, 1);
  setlength(result,0);
  setlength(len,1);
  s_len := copy(s,1,2);
  if s_len = '00' then          // последняя строка, без данных
    exit;
  delete(s,1,8);
  HexToBin(pchar(s_len), pchar(len), 1);
  setlength(result,16);
  hextobin(pchar(s), pchar(result), len[0]);
  for i := len[0] to 15 do             // дополняем 0xFF если необходимо
    result[i] := $FF;
end;

function TPacket.convert_hex(source: string; var dest: TMemoryStream): boolean;
// загружает чистые данные в файл dest
// ДОВОДИТ ДАННЫЕ ДО РАЗМЕРА k*128, вставляя в конец 0xFF
// нужно для пакетов бутлодера
var
  finp: TStringList;
  data: TData;
  i,k: byte;
begin
  result := false;
  finp := TStringList.Create;
  finp.LoadFromFile(source);            // загрузили список строк
  dest := TMemoryStream.Create;         // приемник
  for i := 0 to finp.Count-1 do
  begin
    data := convert_one_string(finp[i]);      // распарсили очередную строку
    if length(data) <> 0 then                 // записали в выходной файл
      for k := 0 to high(data) do
        dest.WriteBuffer(data[k], 1);
  end;
  i := $FF;
  while dest.Size mod 128 <> 0 do      // добавляем 0xFF в конец файла
    dest.WriteBuffer(i, 1);
  dest.Position := 0;
  setlength(data,0);
  result := true;
end;

constructor TPacket.create(source: string);
begin
  convert_hex(source, firmware);
  _is_end := false;
  number := 1;
  firmware.SaveToFile('c:\123');
end;

destructor TPacket.free;
begin
  firmware.Free;
end;

function TPacket.next: string;
// генерирует следующий пакет
var
  csum: byte;
  i: byte;
begin
  if firmware.position <> firmware.size then
  begin
    result := #1;                         // очередной пакет
    result := result + chr(number);       // номер пакета
    result := result + chr(number+1);     // первый байт чексуммы
                                          // данные
    setlength(result, length(result)+128);
    csum := 2*(number + 1);
    for i := 1+3 to 128+3 do              // сразу со смещением
    begin
      firmware.ReadBuffer(result[i], 1);
      inc(csum, ord(result[i]));
    end;
    result := result + chr(csum);         // второй байт чексуммы
    inc(number);
  end else begin                          // генерирую пакет завершения
    result := #4;
    _is_end := true;
  end;
end;

function TPacket.is_end: boolean;
begin
  result := _is_end;
end;

function TPacket.cancel: string;
// генерирует стоп-пакет
begin
  result := #$18;
end;

function TPacket.firmware_overload: boolean;
begin
  result := firmware.Size > $3BFF;
end;

function TPacket.amount: word;
begin
  result := (firmware.Size div 128) + 1; // +1 последний пакет останова
end;

end.
